#!/usr/bin/env python3

import matplotlib.pyplot as plt
import numpy as np
import os

from scipy import signal


test_name = 'dsp_biquad_df2T_single_f32'
n_test_samples = 1

testpath = os.path.join('tests', test_name)
datapath = os.path.join(testpath, 'data')
enable_plots = False
enable_write_to_files = True


def snr(tst, ref):
    sz = min(len(tst), len(ref))
    energy_tst = np.sum(tst * tst)
    energy_err = np.sum((ref - tst) * (ref - tst))
    snr = 10 * np.log10(energy_tst / energy_err)
    return snr


def moving_average(a, n=3):
    ret = np.cumsum(a, dtype=float)
    ret[n:] = ret[n:] - ret[:-n]
    return ret[n - 1:] / n


def write_to_header(fname, n_stages, n_samples, n_initial):
    outdir, f = os.path.split(fname)
    h = f[:f.index('.')].upper()
    if not os.path.exists(outdir):
        os.makedirs(outdir)
    def_fmt = "#define {:<16}{:}"
    with open(fname, 'w') as f:
        f.write("/**\n  * AUTOGENERATED - DO NOT EDIT\n  */\n\n")
        f.write("#ifndef _{:}_\n".format(h))
        f.write("#define _{:}_\n".format(h))
        f.write("\n{:}".format(def_fmt.format("N_STAGES", n_stages)))
        f.write("\n{:}".format(def_fmt.format("N_SAMPLES", n_samples)))
        f.write("\n{:}".format(def_fmt.format("N_INITIAL", n_initial)))
        f.write("\n\n#endif    // _{:}_\n".format(h))


def write_to_file(fname, arr_name, arr, per_line):
    """ Write array to C file """
    outdir, f = os.path.split(fname)
    if not os.path.exists(outdir):
        os.makedirs(outdir)
    float_fmt = '{:13.10f}'  # 13 digits total, 10 decimal points floating-point
    arr_size = len(arr)
    with open(fname, 'w') as f:
        f.write("\n#include \"test_main.h\"")
        f.write("\n#include \"embench_math_types.h\"")
        f.write("\n\nfloat32_t {:}[{:}] = \n{{\n  ".format(arr_name, arr_size))
        for i in range(arr_size):
            if i == (arr_size - 1):
                f.write("{:}f\n".format(float_fmt.format(arr[i])))
            else:
                f.write("{:}f, ".format(float_fmt.format(arr[i])))
                if ((i+1) % per_line) == 0:
                    f.write("\n  ")
        f.write("};\n")


""" Filter Design """
Fs = 48000  # sampling frequency
N = 6  # order
Fc = 1000  # cutoff frequency

n_stages = int(N/2)

sos = signal.iirfilter(N, Fc, btype='lowpass', analog=False, ftype='butter', output='sos', fs=Fs)

# print(len(sos), type(sos))
# print(sos)


""" Input Stimulus """
n_samples = 1024
tone_freq_hz = [100, 4000, 8000]
tone_amp_dB = [-30, -20, -10]
n_tones = len(tone_freq_hz)

n = np.arange(n_samples)
t = n / Fs  # discrete time array
x_100hz = (np.power(10,(tone_amp_dB[0]/20))) * np.sin(2 * np.pi * tone_freq_hz[0] * t)
x = (np.power(10,(tone_amp_dB[0]/20))) * np.sin(2 * np.pi * tone_freq_hz[0] * t)
if n_tones > 1:
    for i in range(1, n_tones):
        x += (np.power(10,(tone_amp_dB[i]/20))) * np.sin(2 * np.pi * tone_freq_hz[i] * t)

# print(len(x), type(x))


""" Filtered Output """
# The filter function is implemented as a series of second-order filters with direct-form II transposed structure.
filtered_x = signal.sosfilt(sos, x)
# print(len(filtered_x), type(filtered_x))

# approximate phase delay for 100 hz tone output
correlation = signal.correlate(filtered_x, x_100hz, mode="full")
lags = signal.correlation_lags(filtered_x.size, x_100hz.size, mode="full")
delay = lags[np.argmax(correlation)]

# ignore noisy output from initial conditions
diff = np.abs(filtered_x[delay:] - x_100hz[:-delay])
diff = moving_average(diff, n=32)
n_initial_samples = np.where(diff < 0.00015)[0][0]


""" Plot """
if enable_plots:
    delay_t = delay / Fs

    plt.figure(1)
    plt.plot(n, x)  # original signal
    plt.plot(n, filtered_x, 'r')  # filtered
    plt.xlabel('sample')
    plt.legend(['x', 'filtered x'])

    # Plot the good part of the filtered signal vs a pure 100hz tone
    plt.figure(2)
    plt.plot(t, x_100hz)  # pure 100hz tone
    plt.plot(t[n_initial_samples:]-delay_t, filtered_x[n_initial_samples:], 'r')  # the "good" part of the filtered signal
    plt.xlabel('time')
    plt.legend(['pure 100hz tone', 'filtered x (good part)'])

    plt.show()


""" Convert SOS to CMSIS-friendly format """
# each row is [b0, b1, b2, a0, a1, a2]
# make sure that a0 = 1 (divide each row by a0)
coeff = sos / sos[:,3].reshape(3,1)
# remove the a0 column and flip the signs of a1 and a2
coeff = np.hstack((coeff[:,:3], -coeff[:,4:]))
# remove the total gain from the first section
# and distribute it across all sections
total_gain = coeff[0,0]
sec_gain = np.power(total_gain, 1/n_stages)
coeff[0,:3] = coeff[0,:3] / total_gain
coeff[:,:3] = coeff[:,:3] * sec_gain
# flatten the array (# stages * 5 coeffs per stage)
coeff = np.reshape(coeff, n_stages*5)


""" Write to file """
if enable_write_to_files:
    testInput = x[:n_initial_samples + n_test_samples]
    refOutput = filtered_x[n_initial_samples:n_initial_samples + n_test_samples]

    elem_per_line = 8
    fname = os.path.join(datapath, 'coeff.c')
    write_to_file(fname, arr_name='coeff', arr=coeff, per_line=elem_per_line)

    fname = os.path.join(datapath, 'refOutput.c')
    write_to_file(fname, arr_name='refOutput', arr=refOutput, per_line=elem_per_line)

    fname = os.path.join(datapath, 'testInput.c')
    write_to_file(fname, arr_name='testInput', arr=testInput, per_line=elem_per_line)

    fname = os.path.join(testpath, 'test_data.h')
    write_to_header(fname, n_stages=n_stages, n_samples=n_test_samples, n_initial=n_initial_samples)
